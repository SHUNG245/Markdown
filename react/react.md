# **注意事项**
> 1 根标签只能有一个，用<></>包裹也行
> 2 插入js表达式用{}
3 函数式组件名必须大写
4 渲染列表用map
5 组件间传值用prop，App（{props，event}）
6 strict模式下react函数式组件会调用两次，Effect也挂载两次，在生产环境下不生效
7 jsx中标签必须闭合
8 组件内不要嵌套定义其他组件
9 jsx内部属性使用驼峰命名法
10 事件处理函数定义在组件内部，且以handle开头，传递而非调用
11 react中onscroll不会传播，只适用于jsx标签
12 子组件标签内部的内容是通过props.children传递的
13 hooks，以use开头的函数只能在组件或者自定义hook的最顶层（定义）调用，不能在条件或者循环或其他嵌套函数中调用
14 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的
15 修改state有两种方式，一种是通过setter传入值直接修改这种React会进行批处理另外一种则是传入一个计算state的函数，这表示在下次渲染前多次更新同一个state
16 state中的对象应该是只读的，要修改里面的属性需要创建一个新的对象 [属性名]：属性值动态创建属性 {...obj, something: 'newValue'} 对象展开语法来创建对象的拷贝。想要减少重复的拷贝代码，可以使用 Immer 传入一个函数，在形参上修改属性
17 state中保存的数组也是只读的，如果要修改则需要复制新数组，对于对象数组则还需要复制对象，使用immer传入更新函数在新参上进行修改
18 对于React来说只要组件在ui树的位置不变那么state就不会重置，即使在jsx中位置发生了改变，属性改变也不会重置，如果想冲着可以通过设置父组件内部唯一的key。在相同位置渲染不同的组件那么组件的整个字数都会被重置
19 reducer，reducer函数接收state和action对象，然后返回新的状态。在组件中使用reducer：通过useReducer导入，传入一个reducer函数和一个初始的state，然后返回一个有状态的值和一个dispatch函数，给dispatch传递action对象来管理组件状态
20 reducer必须是纯粹的，内部不应该包含副作用或者异步任务，每个action都描述一个单独的交互
21 子组件访问组件数中在其上层的数据：context。使用步骤1.定义createContext并传入默认值。2 引入useContext 3 在需要使用数据的子组件useContext（上层创建的context）4在上层组件用<Context.Provider>把子元素包裹，并指定value值
22 useRef()相当于不会重新渲染的usestate，可以通过ref.current获取当前ref值
23 ref作用：记录定时器id，获取ReactDOM（标签设置ref属性，可以传一个值也可以传入一个函数），存储不需要被用来计算 JSX 的其他对象
24 ref暴露自定义的组件需要使用forwardRef（组件）来主动暴露，并接收ref，与props不同，然后再挂载到标签上
25 React更新分为两个阶段：渲染阶段和提交阶段。渲染阶段：调用组件来确定屏幕显示什么。提交阶段：React把变更应用于DOM，effect就是在提交阶段运行的，先更新屏幕再执行effect（可以操作dom ）
26 React逻辑类型：渲染逻辑代码和事件处理程序，还有副作用effect。effect可以指定油渲染本身，而不是特定事件引起的副作用，常用于外部系统进行同步
27 effect用法：1 声明effect；2 指定effect依赖；3 必要时添加清理函数
useEffect（方法，依赖数组）不指定依赖数组会在每次渲染后执行，指定空数组只会在组件首次渲染时执行
28 Effect不要经常使用，使用时或许包裹进自定义hook更好
